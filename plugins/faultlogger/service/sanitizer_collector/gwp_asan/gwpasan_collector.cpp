/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "gwpasan_collector.h"

#include <algorithm>
#include <cerrno>
#include <climits>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <fcntl.h>
#include <iostream>
#include <map>
#include <regex>
#include <securec.h>
#include <stdint.h>
#include <string>
#include <sys/time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <vector>

#include "bundle_mgr_client.h"
#include "hisysevent.h"
#include "faultlog_util.h"
#include "file_util.h"
#include "hilog/log.h"

namespace OHOS {
namespace HiviewDFX {
static constexpr HiLogLabel LABEL = {LOG_CORE, 0xD002D12, "Sanitizer"};

void ReadGwpAsanRecord(std::string& gwpAsanBuffer)
{
    GwpAsanCurrInfo curr_;
    curr_.description = gwpAsanBuffer;
    curr_.pid = getpid();
    curr_.uid = getuid();
    curr_.errType = "GWP-ASAN";
    if (curr_.uid >= 0) {
        curr_.procName = GetApplicationNameById(curr_.uid);
        curr_.appVersion = GetApplicationVersion(curr_.uid, curr_.procName);
    }
    time_t timeNow = time(nullptr);
    uint64_t timeTmp = timeNow;
    std::string timeStr = GetFormatedTime(timeTmp);
    curr_.happenTime = std::stoll(timeStr);

    // Do upload when data ready
    WriteCollectedData(curr_);
    HiSysEventWrite(HiSysEvent::Domain::RELIABILITY, "ADDR_SANITIZER",
                    HiSysEvent::EventType::FAULT,
                    "MODULE", curr_.procName,
                    "VERSION", curr_.appVersion,
                    "REASON", curr_.errType,
                    "PID", curr_.pid,
                    "UID", curr_.uid,
                    "SUMMARY", curr_.description,
                    "HAPPEN_TIME", curr_.happenTime);
}

static bool WriteNewFile(const int32_t fd, const GwpAsanCurrInfo &curr_)
{
    if (fd < 0) {
        return false;
    }

    OHOS::HiviewDFX::FileUtil::SaveStringToFd(fd, std::string("Generated by HiviewDFX @OpenHarmony") + "\n" +
        std::string("=================================================================\n") +
        "TIMESTAMP:" + std::to_string(curr_.happenTime) +  "\n" +
        "Pid:" + std::to_string(curr_.pid) + "\n" +
        "Uid:" + std::to_string(curr_.uid) + "\n" +
        "Process name:" + curr_.procName + "\n" +
        "Fault thread Info:\n" + curr_.description);

    close(fd);
    return true;
}

static std::string CalcCollectedLogName(const GwpAsanCurrInfo &curr_)
{
    std::string filePath = "data/log/faultlog/faultlogger/";
    if (filePath.size() == 0) {
        return filePath;
    }
    std::string prefix = "gwpasan";
    std::string name = curr_.procName;
    if (name.find("/") != std::string::npos) {
        name = curr_.procName.substr(curr_.procName.find_last_of("/") + 1);
    }

    std::string fileName = "";
    fileName.append(prefix);
    fileName.append("-");
    fileName.append(name);
    fileName.append("-");
    fileName.append(std::to_string(curr_.uid));
    fileName.append("-");
    fileName.append(std::to_string(curr_.happenTime));

    std::string fullName = filePath + fileName;

    return fullName;
}

void WriteCollectedData(const GwpAsanCurrInfo &curr_)
{
    std::string fullName = CalcCollectedLogName(curr_);
    if (fullName.size() == 0) {
        return;
    }
    int32_t fd = CreateLogFile(fullName);
    if (fd < 0) {
        return;
    }

    WriteNewFile(fd, curr_);

}

static int32_t CreateLogFile(const std::string& name)
{
    int32_t fd = -1;
    if (!FileUtil::FileExists(name)) {
        HiLog::Warn(LABEL, "file %{public}s is creating now.", name.c_str());
    }
    fd = open(name.c_str(), O_CREAT | O_WRONLY | O_TRUNC);
    return fd;
}

std::string GetApplicationNameById(int32_t uid)
{
    std::string bundleName;
    AppExecFwk::BundleMgrClient client;
    if (client.GetNameForUid(uid, bundleName) != ERR_OK) {
        HiLog::Warn(LABEL, "Failed to query bundleName from bms, uid:%{public}d.", uid);
    } else {
        HiLog::Info(LABEL, "bundleName of uid:%{public}d is %{public}s", uid, bundleName.c_str());
    }
    return bundleName;
}

std::string GetApplicationVersion(int32_t uid, const std::string& bundleName)
{
    AppExecFwk::BundleInfo info;
    AppExecFwk::BundleMgrClient client;
    if (!client.GetBundleInfo(bundleName, AppExecFwk::BundleFlag::GET_BUNDLE_DEFAULT,
                              info, AppExecFwk::Constants::ALL_USERID)) {
        HiLog::Warn(LABEL, "Failed to query BundleInfo from bms, uid:%{public}d.", uid);
        return "";
    } else {
        HiLog::Info(LABEL, "The version of %{public}s is %{public}s", bundleName.c_str(),
                        info.versionName.c_str());
    }
    return info.versionName;
}
} // namespace HiviewDFX
} // namespace OHOS
